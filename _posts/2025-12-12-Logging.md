---
layout: single
title: "프론트엔드 실무 로깅 아키텍처 가이드 (Store + File 기반)"
categories: [Frontend]
tags: [Logging, Architecture, ReactNative, Frontend, Observability]
---

운영 환경에서 발생하는 문제를 추적하기 위해  
**로그(logging)는 선택이 아니라 필수**.

이 글에서는 **특정 상태관리 라이브러리에 종속되지 않는**,  
프론트엔드 전반에서 공통으로 사용할 수 있는  
**실무 로깅 아키텍처 패턴**을 정리.

> React Native 기준으로 설명하지만  
> 구조 자체는 Web / Windows / Android / iOS 모두 적용 가능.

---

# 1. 로깅 아키텍처 개요

권장하는 전체 흐름.

```ts
이벤트(API 호출, 상태 변화)
↓
Logger Core
↓
In-memory Store (로그 큐)
↓
Persistent Storage (파일 / 로컬 저장소)
↓
(선택) 서버 전송
```

핵심 개념.

> **스토어는 큐(queue),  
> 파일은 영속 저장소(persistence)**

---

# 2. Logger Type 설계
## 2-1. 로그 레벨과 타입

```ts
export enum LogLevel {
  INFO = 'INFO',
  WARN = 'WARN',
  ERROR = 'ERROR',
}

export enum LogType {
  API = 'API',
  SYSTEM = 'SYSTEM',
}
```

## 2-2. API 로그 모델

```ts
export interface ApiLog {
  id: string;
  timestamp: number;

  type: LogType.API;
  level: LogLevel;

  name: string;
  method: 'GET' | 'POST' | 'PUT' | 'DELETE';
  url: string;

  status?: number;
  durationMs?: number;

  request?: unknown;
  response?: unknown;
  error?: string;
}
```
> id, timestamp는 내부에서만 생성  
> 로그 생성자에게 맡기지 않는다

--- 

# 3. Logger Core (단일 진입점)

모든 로그는 하나의 함수를 통해서만 생성한다.

```ts
import { v4 as uuidv4 } from 'uuid';

export function logApi(
  log: Omit<ApiLog, 'id' | 'timestamp'>
) {
  const entry: ApiLog = {
    id: uuidv4(),
    timestamp: Date.now(),
    ...log,
  };

  logStore.add(entry);

  if (__DEV__) {
    console.log('[API LOG]', entry);
  }
}
```

--- 

# 4. Store 패턴

```ts
export interface LogStore {
  add(log: ApiLog): void;
  /** 메모리에 쌓인 로그를 파일로 flush */
  flushToFile(): Promise<void>;
  /** 파일에 저장된 로그를 다시 로드 */
  loadFromFile(): Promise<void>;
  clear(): void;
}
```

## 예시 스토어
```ts
export class MemoryLogStore implements LogStore {
  private logs: ApiLog[] = [];
  private fileLogger: FileLogger;

  constructor(fileLogger: FileLogger) {
    this.fileLogger = fileLogger;
  }

  add(log: ApiLog) {
    this.logs.push(log);
  }

  // 파일로 저장하는건 설계에 따라 유용적으로 하도록.
  async flushToFile() {
    for (const log of this.logs) {
      await this.fileLogger.append(log);
    }
    this.logs = [];
  }

  async loadFromFile() {
    const persistedLogs = await this.fileLogger.readAll();
    this.logs = persistedLogs;
  }

  clear() {
    this.logs = [];
  }
}
```

# 5. API 호출 자동 로깅
## 5-1. Axios 인터셉터 기반 로깅 (메타 정보 중심)
인터셉터 로깅은 API 호출 여부, 시간, 상태 코드 등  
**메타 정보 수집에 적합.**

API 로그인경우 인터셉터에서 자동화.
```ts
-- request
api.interceptors.request.use((config) => {
  (config as any).meta = { startTime: Date.now() };

  logApi({
    type: LogType.API,
    level: LogLevel.INFO,
    name: config.url ?? '',
    method: config.method?.toUpperCase(),
    url: config.url ?? '',
    request: config.data,
  });

  return config;
});

-- response
api.interceptors.response.use(
  (response) => {
    const duration =
      Date.now() - response.config.meta.startTime;

    logApi({
      type: LogType.API,
      level: LogLevel.INFO,
      name: response.config.url ?? '',
      method: response.config.method?.toUpperCase(),
      url: response.config.url ?? '',
      status: response.status,
      durationMs: duration,
      response: response.data,
    });

    return response;
  },
  (error) => {
    logApi({
      type: LogType.API,
      level: LogLevel.ERROR,
      name: error.config?.url ?? '',
      method: error.config?.method?.toUpperCase(),
      url: error.config?.url ?? '',
      error: error.message,
    });

    return Promise.reject(error);
  }
);
```
- 실제 운영 환경에서는 request / response 전체를 그대로 로깅하기보다는 민감 정보 제거(masking) 또는 요약 로그를 권장.
- 이러한 민감정보를 하는경우 인터셉터가 아닌 스토어에서 적용하는게 좋음.

## 5-2. Store 기반 로깅 (의미 있는 지점에서의 로그)
인터셉터는 모든 요청을 동일하게 처리.
하지만 실제 서비스에서는 다음과 같은 구분이 필요.

- 로그인 요청
- 결제 처리
- 개인정보 입력
- 설정 변경

이런 이벤트들은
**“API 호출”이 아니라 “비즈니스 이벤트”**.

따라서 이런 로그는
인터셉터가 아니라 **스토어(또는 도메인 레이어)**에서 남기는 것이 안전

## 예시: 로그인 스토어에서의 로그

```ts
class AuthStore {
  login(userId: string, password: string) {
    logApi({
      type: LogType.API,
      level: LogLevel.INFO,
      name: 'LOGIN_ATTEMPT',
      method: 'POST',
      url: '/login',
      request: {
        userId,
        // password는 로그에 남기지 않음
      },
    });

    // 실제 API 호출
    return api.post('/login', { userId, password });
  }
}
```

--- 

# 6. FileLogger
- 파일저장 하는경우.

```ts
import RNFS from 'react-native-fs';
import { ApiLog } from './types';

/**
 * FileLogger 인터페이스
 * - 로그를 파일에 영속 저장
 * - 파일로부터 로그 복원
 */
export interface FileLogger {
  append(log: ApiLog): Promise<void>;
  readAll(): Promise<ApiLog[]>;
  clear(): Promise<void>;
}

/**
 * 기본 FileLogger 구현체
 */
export class DefaultFileLogger implements FileLogger {
  private readonly logDir: string;
  private readonly logFilePath: string;

  constructor(
    dirName: string = 'logs',
    fileName: string = 'api.log'
  ) {
    // 앱 전용 문서 디렉토리 하위
    this.logDir = `${RNFS.DocumentDirectoryPath}/${dirName}`;
    this.logFilePath = `${this.logDir}/${fileName}`;
  }

  /**
   * 로그 1건을 파일에 append
   * - 디렉토리 없으면 생성
   * - 파일 없으면 자동 생성
   */
  async append(log: ApiLog): Promise<void> {
    try {
      await this.ensureLogDir();

      const line = JSON.stringify(log) + '\n';
      await RNFS.appendFile(this.logFilePath, line, 'utf8');
    } catch (error) {
      // 로깅 실패로 앱이 죽으면 안 됨
      console.warn('[FileLogger] append failed', error);
    }
  }

  /**
   * 파일에 저장된 모든 로그를 읽어서 반환
   * - JSON Line 포맷 기준
   */
  async readAll(): Promise<ApiLog[]> {
    try {
      const exists = await RNFS.exists(this.logFilePath);
      if (!exists) return [];

      const content = await RNFS.readFile(this.logFilePath, 'utf8');

      return content
        .split('\n')
        .filter(Boolean)
        .map((line) => JSON.parse(line) as ApiLog);
    } catch (error) {
      console.warn('[FileLogger] readAll failed', error);
      return [];
    }
  }

  /**
   * 로그 파일 삭제
   * - 서버 전송 완료 후 사용
   */
  async clear(): Promise<void> {
    try {
      const exists = await RNFS.exists(this.logFilePath);
      if (exists) {
        await RNFS.unlink(this.logFilePath);
      }
    } catch (error) {
      console.warn('[FileLogger] clear failed', error);
    }
  }

  /**
   * 로그 디렉토리 보장
   */
  private async ensureLogDir(): Promise<void> {
    const exists = await RNFS.exists(this.logDir);
    if (!exists) {
      await RNFS.mkdir(this.logDir);
    }
  }
}
```